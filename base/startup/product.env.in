# Copyright (c) 2018-2019 LG Electronics, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

# Avoid waiting for coalescing touch events in QQuickWindow
export QML_NO_TOUCH_COMPRESSION=1

# Set atlas texture size to 1MB (512 * 512 * 4)
export QSG_ATLAS_WIDTH=512
export QSG_ATLAS_HEIGHT=512

# Release QImages after creating texture
export QSG_TRANSIENT_IMAGES=1

# Keymap
export QT_QPA_EVDEV_KEYBOARD_PARAMETERS=keymap=@WEBOS_INSTALL_DATADIR@/webos-keymap/webos-keymap.qmap

# Define the compositor extensions that will be loaded
export WEBOS_COMPOSITOR_EXTENSIONS=webos-wayland-extension

# Platform plugin to be used
export WEBOS_COMPOSITOR_PLATFORM=eglfs

# Cursor timeout
export WEBOS_CURSOR_TIMEOUT=5000

# Scale factor for High DPI
export QT_SCALE_FACTOR=1.0

# Needed since Qt 5.11
export QT_QPA_EGLFS_ALWAYS_SET_MODE=1

# Display device detection
# DRM_CONNECTORS_EXPECTED of 0 doesn't specify the number of DRM connectors
# which means that it starts with all DRM connectors detected at this point.
# DRM_PROBE_RETRY is valid only if DRM_CONNECTORS_EXPECTED > 0.
WEBOS_COMPOSITOR_DISPLAYS=0
WEBOS_COMPOSITOR_PRIMARY_SCREEN=""
DRM_PROBE_RETRY=10
DRM_CONNECTORS_EXPECTED=0
DRM_CONNECTORS_DETECTED_LIST="$XDG_RUNTIME_DIR/surface-manager.display.lst"
pmlog info "Probing display devices ..."
while true; do
    WEBOS_COMPOSITOR_DISPLAYS=0
    cat /dev/null > $DRM_CONNECTORS_DETECTED_LIST
    for f in $(find /sys/class/drm -name "card*-*" | sort); do
        bn=$(basename $f)
        device=${bn%%-*};    bn=${bn#$device-}
        connector=${bn%%-*}; bn=${bn#$connector-}
        sb=${bn%%-*};        bn=${bn#$sb-}
        id=${bn%%-*}
        enabled=$(cat "$f/enabled")
        status=$(cat "$f/status")
        # Assume available if it reports something other than disconnected
        # because some DRM connector doesn't report its status correctly.
        if [ "$status" != "disconnected" ]; then
            pmlog debug "Display device to use: $device, $connector$id"
            echo "/dev/dri/$device $connector$id" >> $DRM_CONNECTORS_DETECTED_LIST
            WEBOS_COMPOSITOR_DISPLAYS=$(expr $WEBOS_COMPOSITOR_DISPLAYS + 1)
            if [ -z "$WEBOS_COMPOSITOR_PRIMARY_SCREEN" ]; then
                WEBOS_COMPOSITOR_PRIMARY_SCREEN="$connector$id"
            fi
        else
            pmlog warning "Display device unusable: $device, $connector$id ($enabled, $status)"
        fi
        if [ $DRM_CONNECTORS_EXPECTED -gt 0 -a $WEBOS_COMPOSITOR_DISPLAYS -ge $DRM_CONNECTORS_EXPECTED ]; then
            break
        fi
    done

    if [ $DRM_CONNECTORS_EXPECTED -eq 0 -a $WEBOS_COMPOSITOR_DISPLAYS -gt 0 ]; then
        pmlog info "$WEBOS_COMPOSITOR_DISPLAYS display device(s) detected."
        break
    elif [ $DRM_CONNECTORS_EXPECTED -gt 0 -a $WEBOS_COMPOSITOR_DISPLAYS -ge $DRM_CONNECTORS_EXPECTED ]; then
        pmlog info "$WEBOS_COMPOSITOR_DISPLAYS display device(s) detected as expected."
        break
    else
        # Detection incomplete.
        # TODO: Consider using inotify rather than polling.
        if [ $WEBOS_COMPOSITOR_DISPLAYS -eq 0 ]; then
            pmlog crit "No display device detected"
            # Retry until at least one connector becomes available
            sleep 10
        elif [ $DRM_PROBE_RETRY -gt 0 ]; then
            pmlog info "$WEBOS_COMPOSITOR_DISPLAYS display device(s) detected, expecting $DRM_CONNECTORS_EXPECTED"
            DRM_PROBE_RETRY=$(expr $DRM_PROBE_RETRY - 1)
            sleep 1
        else
            pmlog warning "Failed to detect $DRM_CONNECTORS_EXPECTED display device(s). Detected $WEBOS_COMPOSITOR_DISPLAYS only."
            break
        fi
    fi
done

# Touchscreen detection
TOUCHSCREEN_COUNT=0
TOUCHSCREEN_PROBE_RETRY=10
TOUCHSCREEN_DETECTED_LIST="$XDG_RUNTIME_DIR/surface-manager.input.lst"
while true; do
    TOUCHSCREEN_COUNT=0
    cat /dev/null > $TOUCHSCREEN_DETECTED_LIST
    for f in $(find /dev/input -name "event*" | sort); do
        if ( udevadm info -q property $f | grep -q ID_INPUT_TOUCHSCREEN=1 ); then
            pmlog debug "Touchscreen to use: $f"
            echo "$f" >> $TOUCHSCREEN_DETECTED_LIST
            TOUCHSCREEN_COUNT=$(expr $TOUCHSCREEN_COUNT + 1)
        fi
        if [ $WEBOS_COMPOSITOR_DISPLAYS -le $TOUCHSCREEN_COUNT ]; then
            break
        fi
    done

    if [ $WEBOS_COMPOSITOR_DISPLAYS -le $TOUCHSCREEN_COUNT ]; then
        pmlog info "$TOUCHSCREEN_COUNT touchscreen(s) detected."
        break
    fi

    # Detection incomplete.
    # Retry a bit more until we get the same number of touchscreens.
    # TODO: Consider using inotify rather than polling.
    if [ $TOUCHSCREEN_PROBE_RETRY -gt 0 ]; then
        pmlog info "$TOUCHSCREEN_COUNT touchscreen(s) detected, expecting $WEBOS_COMPOSITOR_DISPLAYS"
        TOUCHSCREEN_PROBE_RETRY=$(expr $TOUCHSCREEN_PROBE_RETRY - 1)
        sleep 1
    else
        pmlog warning "Failed to detect $WEBOS_COMPOSITOR_DISPLAYS touchscreen(s). Detected $TOUCHSCREEN_COUNT only."
        break
    fi
done
# Make sure the list has the same count to the number of DRM connectors detected.
if [ $WEBOS_COMPOSITOR_DISPLAYS -gt $TOUCHSCREEN_COUNT ]; then
    c=$(expr $WEBOS_COMPOSITOR_DISPLAYS - $TOUCHSCREEN_COUNT)
    while [ $c -gt 0 ]; do
        echo "none" >> $TOUCHSCREEN_DETECTED_LIST
        c=$(expr $c - 1)
    done
fi

# Generate EGLFS config json file based on devices detected.
# Assume the order of touchscreen devices are the same with
# the order of DRM connectors.
QT_QPA_EGLFS_CONFIG="$XDG_RUNTIME_DIR/surface-manager.eglfs.json"
CONFIG_JSON=$(paste $DRM_CONNECTORS_DETECTED_LIST $TOUCHSCREEN_DETECTED_LIST | awk '
    BEGIN {
        dri = ""
        printf "["
    }
    /^\/dev\/dri\// {
        if ( dri != $1 ) {
            if ( dri != "" )
                printf "]}"
            printf "{\"device\":\"%s\",\"hwcursor\":false,\"outputs\":[", $1
            dri = $1
        } else {
            printf ","
        }
        printf "{\"name\":\"%s\"", $2
        if ( $3 != "none" )
            printf ",\"touchDevice\":\"%s\"}", $3
        else
            printf "}"
    }
    END {
        if ( dri != "" )
            printf "]}"
        printf "]"
    }
    ')
echo $CONFIG_JSON > $QT_QPA_EGLFS_CONFIG

pmlog info "WEBOS_COMPOSITOR_DISPLAYS: $WEBOS_COMPOSITOR_DISPLAYS"
pmlog info "WEBOS_COMPOSITOR_PRIMARY_SCREEN: $WEBOS_COMPOSITOR_PRIMARY_SCREEN"
pmlog info "QT_QPA_EGLFS_CONFIG: $CONFIG_JSON"
export WEBOS_COMPOSITOR_DISPLAYS QT_QPA_EGLFS_CONFIG
